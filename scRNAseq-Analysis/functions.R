# ~~~ Functions File ~~~
# Desc: Contains all functions called in downstream analysis
# 
# Best Practices:
# * Carefully define the purpose of each function, any arguments it takes, and
# *   and anything it returns
# * Single Responsibility: Each function should perform one job and do it well
# * Manage Scope Carefully
# * Parametrize your functions to make them configurable and reusable

LoadPackages <- function() {
  # Desc: Loads all necessary packages cached in compiled CTHC transferred file
  #       Args: None
  #       Returns: Void
  library(jsonlite)
  library(tidyverse)
  library(DropletUtils)
  library(Seurat)
  library(ShinyCell)
  library(Matrix)
  library(scales)
  library(rjson)
  library(R2HTML)
  library(DT)
  library(SeuratDisk)
  # to install SeuratDisk, which is not on CRAN, use the following:
  # if (!requireNamespace("remotes", quietly = TRUE)) {
  #   install.packages("remotes")
  # }
  # remotes::install_github("mojaveazure/seurat-disk")
}

ImportCountData <- function(sample_prefix_array, do_droplet_utils, droplet_threshold=0.05) {
  # Desc: Iterates through each sample filename prefix and creates a raw read mtx
  # Args: sample_prefix_array: Array of sample prefixes specified in JSON Params
  #       do_droplet_utils: bool, from params
  #       droplet_threshold: float, from params
  # Returns: List of raw matrices for later processing
  
  raw_mtx_list <- list()
  
  for(sample in sample_prefix_array){
    # load raw data matrix using the readMM function from the Matrix package
    raw_mtx <- readMM(paste0(sample,'matrix.mtx'))
    
    # load genes
    genes <- read.csv(paste0(sample,'genes.tsv'), sep = '\t', header = F)
    
    # add ensemble gene_ids to the data matrix as rownames
    rownames(raw_mtx) <- genes[,1] 
    
    # add cell barcodes as column names
    barcodes <- read.csv(paste0(sample,'barcodes.tsv'), sep = '\t', header = F) 
    colnames(raw_mtx) <- barcodes[,1]
    
    # Add the read and processed mtx to the list
    raw_mtx_list[[paste0(sample,".mtx")]] <- raw_mtx
  }
  print("Loaded samples:")
  print(names(raw_mtx_list))
  
  #Do Droplet Filtering if requested
  if(do_droplet_utils) {
    print("Filtering out empty droplets")
    #If specified in params, filter empty droplets with DropletUtils
    
    filtered_matrices <- try(FilterDroplets(
      raw_mtx_list, 
      droplet_threshold
    ))
    
    # Error Handling: Be able to proceed if DropletUtils fails
    if(inherits(filtered_matrices, "try-error")) {
      print("Failed to filter via Droplet Utils. Proceeding without filtering.")
      filtered_matrices <- raw_mtx_list
    }
    
  } else {
    #Otherwise, return raw matrices with no changes
    filtered_matrices <- raw_mtx_list
    
  }
  
  CreateCountDirectories(filtered_matrices, genes)
  
}

FilterDroplets <- function(rawmtx_list, threshold) {
  # Desc: Iterates through raw matrices list and removes empty droplets using
  #       DropletUtils based on configured threshold
  # Args: rawmtx_list -- mtx list generated by ImportCountData
  #       threshold -- cutoff threshold for DropletUtils as spec'd in params
  
  # Create empty list to return
  droplet_filtered_matrices <- list()
  
  # Loop through each index of the input mtx list
  for(i in seq_along(rawmtx_list)) {
    
    # Get the sample name
    sample_name <- names(rawmtx_list)[i]
    
    # Get the matrix
    mtx <- rawmtx_list[[i]]
    
    # Use Droplet Utils to determine the probability that each droplet is empty
    out <- emptyDrops(mtx) 
    
    # set threshold probability for calling a cell using spec'd param
    keep <- out$FDR <= threshold
    
    # use threshold to remove empty drops
    keep[is.na(keep)] <- FALSE
    
    # Add filtered matrix to list of matrices to return
    filt_mtx[[sample_name]] <- mtx[,keep] 
    
    total_droplets <- ncol(mtx)
    kept_droplets <- sum(keep)
    rm_droplets <- total_droplets - kept_droplets
    print("Removed ", rm_droplets, " droplets of ", total_droplets, " droplets from ", sample_name)
  }
  
  # Return list of filtered matrices
  return(filt_mtx)
}

CreateCountDirectories <- function(mtx_array, genes) {
  # Desc: Iterates through raw matrices list and creates 10x formatted directories
  # Args: array of matrices generated by ImportCountData
  # Returns: Void
  
  # Create parent directory
  dir.create("./10X_Counts")
  
  # Iterate through each sample mtx to write10xcounts
  for(i in seq_along(mtx_array)) {
    
    # Get sample name
    sample_name <- names(mtx_array)[i]
    
    # Get mtx
    mtx <- mtx_array[[i]]
    
    # Get dir name from sample name
    dir_name <- gsub(".mtx", "", sample_name)
    
    # Assemble dir path
    dir_path <- paste0("./10X_Counts/",dir_name)
    
    write10xCounts(dir_path, gene.symbol = genes[,2], mtx, overwrite = T)
    print(paste0("Created directory: ", dir_name))
    
  }
} 

CreateSeuratObjects <- function(min_cells, min_feat) {
  # Desc: Creates a list of seurat objects generated from 10X_Counts dir
  # Args: min_cells: Sets min # of cells expressing a gene for gene to make cutoff (params)
  #       min_feat: Sets min # of features for a cell to express to make cutoff (params)
  # Returns: List of seurat objects, one object for each sample
  
  # Create empty list of seurat objects to return
  seurat_objects <- list()
  
  for (sample in list.dirs(path = "./10X_Counts", recursive = FALSE)) {
    
    expression_matrix <- Read10X(
      sample,
      gene.column = 2,
      cell.column = 1,
      unique.features = TRUE,
      strip.suffix = FALSE
    )
    
    sample_seurat <- CreateSeuratObject(counts = expression_matrix, min.cells = min_cells, min.features = min_feat)  %>% 
      NormalizeData(verbose = FALSE) %>% 
      FindVariableFeatures(verbose = FALSE)
    
    sample_name <- gsub(".*/", "", sample)
    
    seurat_objects[[sample_name]] <- sample_seurat
    
  }
  
  return(seurat_objects)
}

CountMitochondrialFeatures <- function(seurat_list) {
  # Desc: Counts percent of mitochondrial features for each cell
  #       and appends this to seurat object
  # Args: seurat_list: a list of seurat objects to be filtered
  #       threshold: percent MT features as cutoff (params)
  # Returns: List of seurat objects after annotation
  
  # Create empty list to return
  seurat_objects <- list()
  
  # For each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Get percentage of Mitochondrial features and append to object
    # NOTE: Currently only works with HUMAN features!
    seurat_object[["percent.mt"]] <- PercentageFeatureSet(object = seurat_object, pattern = "^MT-")
    
    # Debug Info
    print(paste0("Calculated mitochondrial feature percentage for :", sample_name))
    
    # Add filtered seurat object to output list
    seurat_objects[[sample_name]] <- seurat_object
  }
  
  # Return annotated seurat list
  return(seurat_objects)
}

FilterSeuratObject <- function(seurat_list, thresholds) {
  # Desc: Filters cells based on a set of parameters
  # Args: seurat_list: A list of seurat objects to be filtered
  #       thresholds: the params$filter_thresholds
  # Returns: A list of filtered Seurat objects
  
  # Create empty list to return
  seurat_objects <- list()
  
  # For each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Get number of cells before filtering
    total_cells <- ncol(seurat_object)
    
    # Get number of features before filtering
    total_features <- nrow(seurat_object)
    
    # Filter out cells
    seurat_object <- subset(seurat_object, 
                            subset = nCount_RNA < thresholds$nCount_RNA_upper & 
                              nCount_RNA > thresholds$nCount_RNA_lower &
                              nFeature_RNA > thresholds$nFeature_RNA_lower &
                              nFeature_RNA < thresholds$nFeature_RNA_upper & 
                              percent.mt < thresholds$percent_mitochondrial
                            )
    
    # Get number of cells after filtering
    remaining_cells <- ncol(seurat_object)
    
    # Get number of features after filtering
    remaining_features <- nrow(seurat_object)
    
    print(paste0(remaining_cells, " cells remaining from ", total_cells, " in ", sample_name))
    print(paste0(remaining_features, " features remaining from ", total_features, " in ", sample_name))
    
    
    # Add filtered seurat object to ouput list
    seurat_objects[[sample_name]] <- seurat_object
  }
  
  # Return annotated seurat list
  return(seurat_objects)
}

AnalyzeDims <- function(seurat_list, dim_red_params) {
  # Desc: Performs scaling, PCA, and dim reduction, and clustering on seurat objects
  # Args: seurat_list: a list of seurat objects to modify
  #       dim_red_params: dimensional reduction parameters from params
  # Returns: a list of modified seurat objects
  
  # Create empty seurat list to return:
  seurat_objects <- list()
  
  # Iterate through each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Perform Scaling
    # To quote Daniel Beiting of DIYTranscriptomics :
    # it is standard practice to apply a linear transformation ('scaling') before PCA. For single cell data this includes:
    # 1. Shifting the expression of each gene, so that the mean expression across cells is 0
    # 2. Scaling the expression of each gene, so that the variance across cells is 1
    # This gives equal weight in downstream analyses, so that highly-expressed genes do not dominate
    seurat_object <- ScaleData(seurat_object, verbose = FALSE)
    
    # Perform PCA
    seurat_object <- RunPCA(seurat_object, 
                            npcs = dim_red_params$PCA_component_count, 
                            verbose = FALSE)
    
    # Perform UMAP if requested
    if(dim_red_params$run_UMAP){
      seurat_object <- RunUMAP(seurat_object,
                               reduction = "pca", 
                               dims = 1:dim_red_params$PCA_component_count)
      
    }
    
    # Perform tSNE if requested
    if(dim_red_params$run_tSNE){
      seurat_object <- RunTSNE(seurat_object,
                               reduction = "pca",
                               dims = 1:dim_red_params$PCA_component_count)
      
    }
    
    # Perform Nearest Neighbor and Clustering analysis
    seurat_object <- FindNeighbors(seurat_object,
                                   reduction = "pca",
                                   dims = 1:dim_red_params$PCA_component_count)
    seurat_object <- FindClusters(seurat_object, resolution = 0.5)
    
    # Add filtered seurat object to ouput list
    seurat_objects[[sample_name]] <- seurat_object
  }
  
  # Return annotated seurat list
  return(seurat_objects)
}

CreateWebApp <- function(seurat)