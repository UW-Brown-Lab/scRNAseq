# ~~~ Functions File ~~~
# Desc: Contains all functions called in downstream analysis
# 
# Best Practices:
# * Carefully define the purpose of each function, any arguments it takes, and
# *   and anything it returns
# * Single Responsibility: Each function should perform one job and do it well
# * Manage Scope Carefully
# * Parametrize your functions to make them configurable and reusable

LoadPackages <- function() {
  # Desc: Loads all necessary packages cached in compiled CTHC transferred file
  #       Args: None
  #       Returns: Void
  library(jsonlite)
  library(tidyverse)
  library(DropletUtils)
  library(Seurat)
  library(ShinyCell)
  library(Matrix)
  library(scales)
  library(rjson)
  library(R2HTML)
  #library(DT)
  library(SingleCellExperiment)
  library(scDblFinder)
  #library(SeuratDisk)
  # to install SeuratDisk, which is not on CRAN, use the following:
  # if (!requireNamespace("remotes", quietly = TRUE)) {
  #   install.packages("remotes")
  # }
  # remotes::install_github("mojaveazure/seurat-disk")
}

ImportCountData <- function(sample_array, do_droplet_utils, droplet_threshold=0.05) {
  # Desc: Iterates through each sample filename prefix and creates a raw read mtx
  # Args: sample_array: Array of samples specified in JSON Params
  #       do_droplet_utils: bool, from params
  #       droplet_threshold: float, from params
  # Returns: Void
  
  for(i in 1:nrow(sample_array)){
    
    # Get Sample
    sample <- sample_array[i,]
    
    # Get Sample Name
    sample_name <- sample$name
    
    # Get Sample File Prefix
    sample_prefix <- sample$file_prefix
    
    # Add .gz to file extension if files are compressed
    if(sample$file_compressed){
      extension <- ".gz"
    }else {extension <- ""}
    
    # load raw data matrix using the readMM function from the Matrix package
    raw_mtx <- readMM(paste0(sample_prefix,'matrix.mtx',extension))
    
    # load genes
    genes <- read.csv(paste0(sample_prefix,'features.tsv', extension), sep = '\t', header = F)
    
    # add ensemble gene_ids to the data matrix as rownames
    rownames(raw_mtx) <- genes[,1] 
    
    # add cell barcodes as column names
    barcodes <- read.csv(paste0(sample_prefix,'barcodes.tsv', extension), sep = '\t', header = F) 
    colnames(raw_mtx) <- barcodes[,1]
    
    #Do Droplet Filtering if requested
    if(do_droplet_utils) {
      print("Filtering out empty droplets")
      #If specified in params, filter empty droplets with DropletUtils
      
      filtered_mtx <- try(FilterDroplets(
        raw_mtx, 
        sample_name,
        droplet_threshold
      ))
      
      # Error Handling: Be able to proceed if DropletUtils fails
      if(inherits(filtered_mtx, "try-error")) {
        print("Failed to filter via Droplet Utils. Proceeding without filtering.")
        filtered_mtx <- raw_mtx
      }
      
    } else {
      #Otherwise, return raw matrices with no changes
      filtered_mtx <- raw_mtx
      
    }
    
    
    
    # Convert to 10X Counts format
    CreateCountDirectories(filtered_mtx, sample_name, genes)
    
  }
  

}

FilterDroplets <- function(mtx, sample_name, threshold) {
  # Desc: Filters raw matrix and removes empty droplets using
  #       DropletUtils based on configured threshold
  # Args: mtx -- matrix generated by ImportCountData
  #       sample_name -- sample name
  #       threshold -- cutoff threshold for DropletUtils as spec'd in params
  # Returns: filtered matrix object
    
    # Use Droplet Utils to determine the probability that each droplet is empty
    out <- emptyDrops(mtx) 
    
    # set threshold probability for calling a cell using spec'd param
    keep <- out$FDR <= threshold
    
    # use threshold to remove empty drops
    keep[is.na(keep)] <- FALSE
    
    # Create filtered matrix
    filt_mtx <- mtx[,keep] 
    
    total_droplets <- ncol(mtx)
    kept_droplets <- sum(keep)
    rm_droplets <- total_droplets - kept_droplets
    print("Removed ", rm_droplets, " droplets of ", total_droplets, " droplets from ", sample_name)
  
  # Return filtered matrix
  return(filt_mtx)
}

CreateCountDirectories <- function(mtx, sample_name, genes) {
  # Desc: Iterates through raw matrices list and creates 10x formatted directories
  # Args: mtx: a single matrix generated by ImportCountData
  #       sample_name: name of the sample to be used in directory creation
  #       genes: the parsed features.tsv object from ImportCountData
  # Returns: Void
  
  # Check if directory exists
  if (!dir.exists("./10X_Counts")){
    # Create parent directory
    dir.create("./10X_Counts")
  }
    
    # Get dir name from sample name
    dir_name <- sample_name
    
    # Assemble dir path
    dir_path <- paste0("./10X_Counts/",dir_name)
    
    write10xCounts(dir_path, gene.symbol = genes[,2], mtx, overwrite = T)
    print(paste0("Created directory: ", dir_name))
    
} 

CreateSeuratObjects <- function(min_cells, min_feat) {
  # Desc: Creates a list of seurat objects generated from 10X_Counts dir
  # Args: min_cells: Sets min # of cells expressing a gene for gene to make cutoff (params)
  #       min_feat: Sets min # of features for a cell to express to make cutoff (params)
  # Returns: List of seurat objects, one object for each sample
  
  # Create empty list of seurat objects to return
  seurat_objects <- list()
  
  for (sample in list.dirs(path = "./10X_Counts", recursive = FALSE)) {
    
    expression_matrix <- Read10X(
      sample,
      gene.column = 2,
      cell.column = 1,
      unique.features = TRUE,
      strip.suffix = FALSE
    )
    
    sample_seurat <- CreateSeuratObject(counts = expression_matrix, min.cells = min_cells, min.features = min_feat)  %>% 
      NormalizeData(verbose = FALSE) %>% 
      FindVariableFeatures(verbose = FALSE)
    
    sample_name <- gsub(".*/", "", sample)
    
    seurat_objects[[sample_name]] <- sample_seurat
    
  }
  
  return(seurat_objects)
}

CountMitochondrialFeatures <- function(seurat_list) {
  # Desc: Counts percent of mitochondrial features for each cell
  #       and appends this to seurat object
  # Args: seurat_list: a list of seurat objects to be filtered
  #       threshold: percent MT features as cutoff (params)
  # Returns: List of seurat objects after annotation
  
  # Create empty list to return
  seurat_objects <- list()
  
  # For each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Get percentage of Mitochondrial features and append to object
    # NOTE: Currently only works with HUMAN features!
    seurat_object[["percent.mt"]] <- PercentageFeatureSet(object = seurat_object, pattern = "^MT-")
    
    # Debug Info
    print(paste0("Calculated mitochondrial feature percentage for :", sample_name))
    
    # Add filtered seurat object to output list
    seurat_objects[[sample_name]] <- seurat_object
  }
  
  # Return annotated seurat list
  return(seurat_objects)
}

FilterSeuratObject <- function(seurat_list, thresholds) {
  # Desc: Filters cells based on a set of parameters
  # Args: seurat_list: A list of seurat objects to be filtered
  #       thresholds: the params$filter_thresholds
  # Returns: A list of filtered Seurat objects
  
  # Create empty list to return
  seurat_objects <- list()
  
  # For each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Get number of cells before filtering
    total_cells <- ncol(seurat_object)
    
    # Get number of features before filtering
    total_features <- nrow(seurat_object)
    
    # Filter out cells
    seurat_object <- subset(seurat_object, 
                            subset = nCount_RNA < thresholds$nCount_RNA_upper & 
                              nCount_RNA > thresholds$nCount_RNA_lower &
                              nFeature_RNA > thresholds$nFeature_RNA_lower &
                              nFeature_RNA < thresholds$nFeature_RNA_upper & 
                              percent.mt < thresholds$percent_mitochondrial
                            )
    
    # Get number of cells after filtering
    remaining_cells <- ncol(seurat_object)
    
    # Get number of features after filtering
    remaining_features <- nrow(seurat_object)
    
    print(paste0(remaining_cells, " cells remaining from ", total_cells, " in ", sample_name))
    print(paste0(remaining_features, " features remaining from ", total_features, " in ", sample_name))
    
    
    # Add filtered seurat object to ouput list
    seurat_objects[[sample_name]] <- seurat_object
  }
  
  # Return annotated seurat list
  return(seurat_objects)
}

AnalyzeDims <- function(seurat_list, dim_red_params) {
  # Desc: Performs scaling, PCA, and dim reduction, and clustering on seurat objects
  # Args: seurat_list: a list of seurat objects to modify
  #       dim_red_params: dimensional reduction parameters from params
  # Returns: a list of modified seurat objects
  
  # Create empty seurat list to return:
  seurat_objects <- list()
  
  # Iterate through each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Perform Scaling
    # To quote Daniel Beiting of DIYTranscriptomics :
    # it is standard practice to apply a linear transformation ('scaling') before PCA. For single cell data this includes:
    # 1. Shifting the expression of each gene, so that the mean expression across cells is 0
    # 2. Scaling the expression of each gene, so that the variance across cells is 1
    # This gives equal weight in downstream analyses, so that highly-expressed genes do not dominate
    seurat_object <- ScaleData(seurat_object, verbose = FALSE)
    
    # Perform PCA
    seurat_object <- RunPCA(seurat_object, 
                            npcs = dim_red_params$PCA_component_count, 
                            verbose = FALSE)
    
    # Perform UMAP if requested
    if(dim_red_params$run_UMAP){
      seurat_object <- RunUMAP(seurat_object,
                               reduction = "pca", 
                               dims = 1:dim_red_params$PCA_component_count)
      
    }
    
    # Perform tSNE if requested
    if(dim_red_params$run_tSNE){
      seurat_object <- RunTSNE(seurat_object,
                               reduction = "pca",
                               dims = 1:dim_red_params$PCA_component_count)
      
    }
    
    # Perform Nearest Neighbor and Clustering analysis
    seurat_object <- FindNeighbors(seurat_object,
                                   reduction = "pca",
                                   dims = 1:dim_red_params$PCA_component_count)
    seurat_object <- FindClusters(seurat_object, resolution = 0.5)
    
    # Add filtered seurat object to ouput list
    seurat_objects[[sample_name]] <- seurat_object
  }
  
  # Return annotated seurat list
  return(seurat_objects)
}

CreateWebApp <- function(seurat_list, parameters) {
  # Desc: Creates interactive ShinyCell webapp for data exploration
  # Args: seurat_list: A list of seurat objects
  #       parameters: Imported params
  # Returns: Void
  
  # Create directory for ShinyCell Files
  dir.create("./ShinyCellFiles")
  
  # Get ShinyCell specific params (for readability)
  sc_params <- parameters$shinycell_settings
  
  # Create empty vector of Sample prefixes for combining them into 1 app
  sc_prefixes <- c()
  
  # Iterate through each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Create ShinyCell Config
    shiny_cell_config <- createConfig(seurat_object)
    
    # INSERT CODE HERE FOR FUTURE SHINYCELL CONFIG MODIFICATION
    
    # Check if seurat object is integrated
    is_integrated <- "integrated" %in% Assays(seurat_object)
    
    # Set assay to RNA or Integrated as necessary
    if(is_integrated){
      shiny_assay <- "integrated"
    }else{
        shiny_assay <- "RNA"
        }
    
    makeShinyFiles(seurat_object, 
                   shiny_cell_config,
                   gex.assay = shiny_assay,
                   gex.slot = "data",
                   gene.mapping = TRUE,
                   shiny.prefix = sample_name,
                   shiny.dir = "./ShinyCellFiles/")
    
    sc_prefixes <- c(sc_prefixes, sample_name)
  }
  
  # Assemble Shiny Cell App
  makeShinyCodesMulti(
    shiny.title = "test",
    shiny.headers = sc_prefixes,
    shiny.prefix = sc_prefixes,
    shiny.dir = "./ShinyCellFiles/",
    shiny.footnotes = sc_params$footnote
  )
  
}

IntegrateSeuratData <- function(seurat_list, parameters) {
  # Desc: Integrates Seurat Data Sets according to params
  # Args: seurat_list: A list of all seurat objects
  #       parameters: imported parameters=
  # Returns: Modified list of seurat objects
  
  # Create empty list to return
  seurat_objects <- list()
  
  # Create empty list of integrated Seurats that need Dim analysis
  int_seurat_objects <- list()

  # Iterate through all samples and add them to output
  for(i in seq_along(seurat_list)) {
    
    # Re-add the each unintegrated seurat object
    seurat_objects[[names(seurat_list)[i]]] <- seurat_list[[i]]
    
  }
  
  # Create a dataframe of samples with integration groups
  samples_df <- parameters$study_design$samples %>%
    filter(!is.na(integration_group))
  
  # Get a list of integration groups
  unique_groups <- unique(samples_df$integration_group)
  
  # Iterate through each group
  for(group in unique_groups) {
    # Subset the dataframe
    subset_df <- samples_df[samples_df$integration_group == group]
    
    # Create empty standalone list
    object_list <- c()
    
    # Refactor later 
    # Create Standalone Seurat Objects
    for(object in subset_df$name) {
      assign(object, seurat_list[[object]])
      object_list <- c(object_list, get(object))
    }
    
    # Find integration features for samples
    integration_features <- SelectIntegrationFeatures(object_list
      )
    
    # Find integration anchors for samples
    integration_anchors <- FindIntegrationAnchors(
      object.list = object_list,
      anchor.features = integration_features
      )
    
    # Create integrated seurat set
    integrated_seurat <- IntegrateData(integration_anchors)
    
    # Add to output list
    int_seurat_objects[[group]] <- integrated_seurat
    
  }
  
  int_seurat_objects <- AnalyzeDims(int_seurat_objects, parameters$dimensional_reduction_settings)
  
  seurat_objects <- c(int_seurat_objects, seurat_objects)
  
  # Return updated seurat list
  return(seurat_objects)
  
}

GenerateSCEobjects <- function(seurat_list) {
  # Desc: Takes a list of seurat objects and returns a list of sce objects
  # Args: seurat_list: A list of seurat objects
  # Returns: a list of sce objects
  
  # Create empty list to return
  sce_objects <- list()
  
  # For each seurat object
  for(i in seq_along(seurat_list)) {
    
    # Get Seurat object
    seurat_object <- seurat_list[[i]]
    
    # Get Sample name
    sample_name <- names(seurat_list)[i]
    
    # Convert seurat to sce
    sce_obj <- as.SingleCellExperiment(seurat_object)
    
    # Add sce object to output list
    sce_objects[[sample_name]] <- sce_obj
  }
  
  # Return sce list
  return(sce_objects)
}

IdentifyDoublets <- function(sce_list) {
  # Desc: Takes a list of sce objects and returns a list of annotated sce objects
  # Args: sce_list: A list of sce objects
  # Returns: a list of sce annotated objects
  
  # Create empty list to return
  sce_objects <- list()
  
  # Iterate through each sce object
  for(i in seq_along(sce_list)) {
    
    # Get sce object
    sce_object <- sce_list[[i]]
    
    # Get Sample name
    sample_name <- names(sce_list)[i]
    
    # Identify Doublets (uses random method)
    sce_object <- scDblFinder(sce_object)
    
    # Add sce object to output list
    sce_objects[[sample_name]] <- sce_object
  }
  
  # Return sce list
  return(sce_objects)
}

RemoveDoublets <- function(sce_list) {
  # Desc: Takes a list of sce objects, indentifies doublets, and removes them.
  # Args: sce_list: A list of sce objects
  # Returns: a list of filtered sce objects
  
  # Create empty list to return
  sce_list <- IdentifyDoublets(sce_list)
  
  # Iterate through each sce object
  for(i in seq_along(sce_list)) {
    
    # Get sce object
    sce_object <- sce_list[[i]]
    
    # Get Sample name
    sample_name <- names(sce_list)[i]
    
    # Identify Doublets (uses random method)
    sce_object <- sce_object[,sce_object$scDblFinder.class == "singlet"]
    
    # Add sce object to output list
    sce_objects[[sample_name]] <- sce_object
  }
  
  # Return sce list
  return(sce_objects)
}